import sys

k, n = map(int, input().split())
k_list = []
for i in range(k):
    k_list.append(int(sys.stdin.readline().rstrip()))


# -------------------- binary search 사용 코드 -----------------------
k_list.sort()   # 가장 길이가 긴 케이블을 구하기 위해 정렬
# print(k_list)
best_long = k_list[-1]  # 가장 길이가 긴 케이블을 best_long에 저장
start = 1
end = best_long

while(start <= end):
    cable_count = 0
    mid = (start + end) // 2

    for i in k_list:
        cable_count = cable_count + (i // mid)

    if cable_count >= n:
        start = mid + 1
    else:
        end = mid - 1
print(end)


# 지금 코드 반례
'''우
2 10
1
100

정답은 10
'''



'''
문제를 풀이하며 고민한 과정

2022/03/30
1. 가지고 있는 랜선들의 길이 총합을 구한다.
2. N개의 랜선을 만들어야 하므로, 1번을 N으로 나눈다.
3. 2번길이부터 점차 1씩 줄여가며 최초로 n개의 케이블이 만들어지는 길이를 탐색 시작
시간초과 문제 발생

더 고민해보자..
탐색범위가 100만이라서 이분탐색으로 시간복잡도를 줄여아 할 것 같은데.. 흠..

2022/04/06
생각난 방법,
k_list부분을 sum으로 
그리고, 탐색 부분을 1씩 줄이지 말고 이진탐색 방법론으로 탐색

2022/04/09 
문제의 입력 조건을 보았을 떄, 
랜선의 길이는 231-1보다 작거나 같은 자연수이다.
라는 문구에서 알 수 있듯, 길이 범위가 굉장히 크다.
따라서 이분탐색을 적용해서 풀이해야 하는 문제이다.

# 우선, 가장 길이가 긴 케이블 long_l을 찾는다.
# 0~long_l 의 중간점 mid을 구한다.
# 모든 케이블을 mid으로 나눈 몫의 합 cable_count을 구한다.
# cable_count == N이면 탐색 종료
# cable_count < N이면 end을 mid-1으로 옮기고 다시 중간점 m을 구한다.
# cable_count > N이면 start을 mid+1으로 옮기고 다시 중간점 m을 구한다.
# 이떄의 mid을 반환

2022/04/17
반례1
2 2 
1
1

반례2
25 421
25468
42380
34638
19901
35751
24933
15368
854
24429
35451
32479
22039
24149
45061
34767
5716
13347
11121
19624
12193
34154
24840
40357
5152
42609

답: 1443

바로 위의 반례의 경우, 
mid = 1442일때와,
mid = 1443일때 모두 cable_count가 421인데,
내가 작성한 코드에서는 mid가 1442로 나온다.
그런데, 정답은 1443이다.
문제가 뭘까?

반례
4 4
5
1
1
1

답: 1


9 3785
73085
6747
87849
30807
79944
26905
92558
15313
2016

답: 109


2022/04/30
mid를 반환하는 것이 아니라 end를 반환해야한다.
왜냐하면, mid인 경우가 절대 없을 수도 있기 떄문이다.
1차이를 경계로 한쪽에서는 n보다 작고, 한쪽에서는 n보다크게 나올 수 있다.
"정확히" n개라고 하지 않았기 때문에, n개를 얻을수 있다면 정답으로 봐야한다.
즉, n+3개를 얻었다면 나머지는 버리면 되는 셈이다.
'''