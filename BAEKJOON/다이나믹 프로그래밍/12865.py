import sys

# 물품 수 N, 버틸수 있는 무게 K
n, k = map(int, input().split())

# 물건 목록을 저장할 리스트
item_list = []

# 버틸수 있는 무게 k에 대하여 dp table 생성
dp = [0] * (k + 1)

# 물건들의 무게와 가치를 item_list에 저장
for i in range(n):
    w, v = map(int, sys.stdin.readline().split())
    if w > k:   # 만약에 현재 물건의 무게w가 버틸수 있는 무게 k보다 크면
        continue # continue로 건너뛰기
    for j in range(k, 0, -1):  # 버틸수 있는 무게를 k부터 1이 될 때 까지 순회
        if j + w <= k and dp[j] != 0:   # 만약에 현재 버틸수 있는 무게k + 현재 물건의 무게가 총 버틸수 있는 무게 k보다 작거나 같고, dp[j]가 0이 아니라면
            dp[j + w] = max(dp[j + w], dp[j] + v)
    dp[w] = max(dp[w], v)   # 0번째에 대해서는 무조건 해줘야 한다.

print(max(dp))

'''
n = 4, k = 7

A 6 13
B 4 8
C 3 6
D 5 12

ABCD    w, v

0000    0, 0
0001    5, 12
0010    3, 6
0011    8, 18   (X) w가 k를 넘었으므로 계산할 필요가 없다. 
0100    4, 8
0101    (X)
0110    7, 14
0111    (X)
---------------------------(6, 13)
1000    6, 13
1001    (X)
1010    (X)
1011    (X)
1100    (X)
1101    (X)
1110    (X)
1111    (X)



A 6 13
B 4 8
C 3 6
D 5 12

(W에 대해서 테이블을 만들자.)
         (i)
    w  A  B  C  D
    0  0  0  0  0
    1  0  0  0  0
    2  0  0  0  0
(j) 3  0  0  6  6
    4  0  8  8  8
    5  0  0  0  12
    6  13 13 13 13
    7  0  0  14 14
    
w = [6,  4, 3, 5]
v = [13, 8, 6, 12]

dp[i][j + w[i]] = max(dp[i - 1][j + w[i]], dp[i - 1][j] + v[i])

그리고, i가 0일때의 결과값은 i가 1일 때의 결과값을 구하는데에 사용되는데, 
i가 2일때의 결과값을 구할 때, i가 1일 때의 결과값은 필요하지만, i가 0일때의 결과값은 필요하지 않다.
따라서 dp테이블을 2차원으로 만들 필요 없이, 1차원으로 해결이 가능하다.
단, 뒤에서부터 계산을 해야한다.
'''