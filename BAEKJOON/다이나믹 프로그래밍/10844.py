'''
45646 이라는 수가 있다.
이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

n이 1이면
1
2
3
4
5
6
7
8
9
총 9개가 계단수가 된다.
한자리수는 0을 제외하고는 모두 다 계단수가 될 수 있다.

2이면?
10  // 1보다 1작은것
12  // 1보다 1 큰것
21
23
32
34
45
43
54
56
65
67
76
78
87
89
98 -> 9에 대해서는 올 수 있는 것이 1개다
2 * 8 + 1
총 17개다.

n이 3이면?
10  // 1보다 1작은것// 맨 뒤에 숫자에 대해서만 계산해주면 된다. 0도 뒤에 올 수 있는 것이 1밖에 없다. 따라서 9와 0은 뒤에 올 수 있는 것이 1개 뿐이다.
12  // 1보다 1 큰것//
21
23
32
34
45
43
54
56
65
67
76
78
87
89
98


i)
결국, 맨 뒤가 0이 몇개있고, 1이 몇개 있는지 등 만 알면 된다는 것이다. 각 숫자에 대하여 몇개씩 있는지가 궁굼한 것이다
  1 2 3 n...
0 0 1 1
1 1 1 3
2 1 2 3
3 1 2 4
4 1 2 4
5 1 2 4
6 1 2 4
7 1 2 4
8 1 2 3
9 1 1 2
 1열의 값을 다 더하면 n이 1일때의 계단수의 개수가 나올 것이고, 이것을 1,000,000,000로 나눈 나머지를 출력하면 n 이 1일 때의 정답이다.
 2열의 값을 다 더하면 n이 2일때의 계단수의 개수가 나올 것이고, 이것을 1,000,000,000로 나눈 나머지를 출력하면 n 이 2일 때의 정답이다.

'''
import sys

def solve():
    n = int(sys.stdin.readline().rstrip())  # n 입력받기

    dp = [[0] * 10 for _ in range(n)]   # 0 ~ 9의 갯수를 n개 저장할 수 있는 dp 테이블 선언 및 초기화

    for i in range(1, 10):  # n이 1 일 때의 계단 수를 저장하기
        dp[0][i] = 1

    for len_n in range(1, n):
        for last_num in range(10):
            if last_num == 0:   # 뒷자리가 0인 경우
                dp[len_n][last_num] = dp[len_n - 1][last_num + 1]   # 예를 들어 n이 2이고 뒷자리가 0이면 계단수로는 10만 가능 9는 불가능
            elif last_num == 9: # 뒷자리가 9인 경우
                dp[len_n][last_num] = dp[len_n - 1][last_num - 1]   # 예를 들어 n이 2이고 뒷자리가 9이면 계단수로는 98만 가능, 100은 불가능
            else:   # 뒷자리가 0과 9가 아닌 경우
                dp[len_n][last_num] = dp[len_n - 1][last_num - 1] + dp[len_n - 1][last_num + 1]

    print(sum(dp[n - 1]) % 1000000000)

solve()