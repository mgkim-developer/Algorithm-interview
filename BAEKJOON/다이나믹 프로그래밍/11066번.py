'''
소설을 여러 장(chapter)로 나누어 쓰는데,
각 장은 각각 다른 파일에 저장하곤 한다.

소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종 소설완성본이 들어있는 한 개의 파일 만듦.
이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고,
이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다.
이 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

ex) C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고,
파일 크기가 각각 [C1:40, C2:30, C3:30, C4:50] 이라고 하자.

이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐 임시파일 X1을 만든다. 이때 비용은 30 + 30 = 60이다

그다음, C1과 X1을 합쳐 임시파일 X2를 만든다. 이때 비용은 40  +60 = 100이다.

최종적으로 X2와 C4를 합쳐 최종 파일을 만들면 비용은 50 + 100 = 150 이다.

따라서 최종의 한 파일을 만드는데 필요한 비용의 합은 60 + 100 + 150 = 310 이다.

만약 다른 방법으로 파일을 합치면 비용을 줄일 수 있다.
먼저 C1과 C2를 합쳐 임시 파일 Y1을 만들면 비용은 40 + 30 = 70
C3와 C4를 합쳐 임시파일 Y2를 만들면 비용은 30 + 50 = 80
그리고 Y1과 Y2를 합쳐 최종파일을 만들면 70 + 80 + 150 = 300 이다.

소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.

i)
문제에서 '소설의 여러 장들이 연속이 되도록 파일을 합쳐나간다' 라고 했으므로 처음에 인접한 파일끼리만 합칠 수 있다.
임의로 파일을 정렬한 뒤 합치면 안된다.

중복되는 합을 저장해 놓자.

 40    30       30          50
  A     B        C           D                              E
A 0     AB       BC + ABC    AB + CD + ABCD(다 더하는 비용)
B       0        BC          BC + BCD
C                0           CD
D                            0
E                                                            0

 40    30       30          50
  A     B        C           D                              E
A 0     70       160         300
B       0        80          170
C                0           80
D                            0
E                                                            0

f(p, q)라고 했을 때, p번째 부터 q번째 까지의 합중 최솟값 이라고 하면,
f(p, q) = min((f(p, p) + f(p + 1, q)), (f(p, p + 1) + f(p + 2, q)), ...)

f(A, C)는 min(AA + BC, AB + CC) = min(BC, AB)
예를 들어 (40, 30, 30, 50) 이 있다면,
f(0, 2)는 min(0 + 30 + 30, 40 + 30 + 0) = min(60, 70) = 60

f(C, D)는 min(BB + CD, BC + DD) = min(CD, BC)
f(3, 4)는 min(0 + 30 + 50, 30 + 30 + 0) = min(80, 60) = 60 = BC

f(A, D) = min(f(A, A) + f(B, D), # BC + BCD => 60 + 110 = 170
              f(A, B) + f(C, D), # AB + CD  => 70 + 80 = 150
              f(A, C) + f(D, D)) # BC + ABC => 60 + 100 = 160

결국 이 로직대로 구현하면, 2차원 배열을 채우는 것이기 때문에 time complexity는 O(N^2)가 된다.
'''
import math
import sys

def solve():
    n = int(sys.stdin.readline().rstrip())
    arr = [int(x) for x in sys.stdin.readline().rstrip().split()]
    rst = [[0 for _ in range(n)] for _ in range(n)]
    for j in range(1, n): # j가 열,  AA는 0인데 초기화 0이므로 인덱스 1부터 시작
        for i in range(j - 1, -1, -1):    # i가 행
            small = math.inf    # 최솟값을 구해야 하므로 처음에는 inf로 초기화
            for k in range(j - i):
                small = min(small, rst[i][i + k] + rst[i + k + 1][j])
            rst[i][j] = small + sum(arr[i : j + 1]) # small + i부터 j번째 까지 다 더한 비용
    print(rst[0][n - 1])

t = int(sys.stdin.readline().rstrip())
for _ in range(t):
    solve()
