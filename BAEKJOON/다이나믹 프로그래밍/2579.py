'''
시작점에서 출발하여 마지막 도착 계단까지 가는 경로 중에, 가중치가 가장 큰 경로를 찾아서 해당 가중치를 반환해야한다.

규칙으로는,
한번에 한계단 또는 두 계단씩 오를 수 있고,
연속된 세 개의 계단을 모두 밟아서는 안된다.(시작점은 포함X)
마지막 도착 계단은 무조건 밟아야 한다.

i)
n 번째 계단을 오르기 위해서는, 모두 4가지 경우의 수가 있다고 가정할 수 있다.
1. 한 계단 or 두 계단 올라서 n - 1 번째 계단에 도착한 후 한 계단 오르기 (총 2가지)
2. 한 계단 or 두 계단 올라서 n - 2 번째 계단에 도착한 후 두 계단 오르기 (총 2가지)
그러나, 여기서 문제에서 주어진 연속 3계단을 오를 수 없다는 조건에 의해, "한 계단 올라서 n - 1계단에 도착한 후, 한 계단 오르기"의 경우는 탈락
총 3가지 경우가 남는다.

dp[i][0] = 한 계단 올라서 i번째 계단에 도착한 경우
dp[i][1] = 두 계단 올라서 i 번째 계단에 도착한 경우

구현해보자.

주의할 것은, 만약에 dp테이블의 길이를 n + 1로 해주면,
n이 1일때,
dp[i][1]이 갱신하는 과정에서, dp[i][0]에서 갱신한 값을 사용하는 문제가 발생한다.

예를 들어 입력이
1
20 이라면,
길이가 n + 1인 dp테이블을 선언 한다면,

i = 0
dp[0][0] = dp[0 - 1][1] + stair[0] = 0 -> [[0, 0], [0, 0]]
dp[0][1] = max(dp[0 - 2]) + stair[0] = 0 -> [[0, 0], [0, 0]]

i = 1
dp[1][0] = dp[1 - 1][1] + stair[1] = 20 -> [[0, 0], [20, 0]]
dp[1][1] = max(dp[1 - 2]) + stair[1] = 20 + 20 = 40 -> [[0, 0], [20, 40]]

------------------------------------------------------------------------
따라서 이러한 문제를 방지하기 위해,

dp 테이블의 길이를 n + 2로 선언 해주어야 한다.

i = 0
dp[0][0] = dp[0 - 1][1] + stair[0] = 0 -> [[0, 0], [0, 0], [0, 0]]
dp[0][1] = max(dp[0 - 2]) + stair[0] = 0 -> [[0, 0], [0, 0], [0, 0]]

i = 1
dp[1][0] = dp[1 - 1][1] + stair[1] = 20 -> [[0, 0], [20, 0], [0, 0]]
dp[1][1] = max(dp[1 - 2]) + stair[1] = 20 -> [[0, 0], [20, 20], [0, 0]]

이렇게 문제가 없게된다.

이러한 문제는 DP 유형을 풀다보면, 많이 접할 것이다.
주의사항을 기억해 놓도록 하자.
'''
import sys

n = int(sys.stdin.readline().rstrip())

stair = []
for i in range(n):
    w = int(sys.stdin.readline().rstrip())
    stair.append(w)
stair.insert(0, 0)
# print(stair)

dp = [[0, 0] for _ in range(n + 2)]

for i in range(n + 1):
    dp[i][0] = dp[i - 1][1] + stair[i]
    # print(dp)
    dp[i][1] = max(dp[i - 2]) + stair[i]
    # print(dp)

print(max(dp[n]))