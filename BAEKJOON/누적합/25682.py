'''
M * N  크기의 보드가 있는데, 어떤 정사각형은 검은색으로 칠해져있고, 나머지는 휜색으로 칠해져있음.
이 보드를 잘라서 K * K 크기의 체스판으로 만들려고함.

정상적인 체스판은 검은색과 휜색이 번갈아서 칠해져 있어야 함.
구체적으로, 각 칸이 검은색과 휜색 중 하나로 칠해져 있으면서,
변을 공유하는 두개의 사각형은 다른 색으로 칠해져 있어야 함.
이 정의를 따르면, 체스판을 색칠하는 경우는 두 가지 뿐이다.
1. 맨 왼쪽 위 칸이 휜색인 경우,
2. 맨 왼쪽 위 칸이 검은색인 경우

보드가 체스판 처럼 칠해져 있다는 보장이 없어서,
M * N 크기의 보드를 K * K 로 자른 후, 몇개의 정사각형을 다시 칠해서 체스판으로 만들 것임.

다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성 할 것.

입력은
첫째 줄에 N(세로)행, M(가로)열, K
둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어짐. (B는 검은색, W는 휜색)
1 <= N, M <= 2000
1 <= K <= min(N, M)


i)
간단한 예제를 먼저 시뮬레이션 해보자.
4 4 3
BBBB
BBBB
BBBW
BBWB
이면,
3 * 3 크기로 자른 후, 가장 적은 칸을 칠해서 체스판을 만들 수 있는 것의 칸 개수를 구해야 한다.
그러면, 일단은 4 * 4 보드를 3 * 3으로 자를 수 있는 경우를 구하고,
각 경우에 대해서 좌측 상단이 B일 때와, W일 때로 나누어
몇개를 다시 색칠해야 하는지 구해서 비교해볼 수 있을 것이다.

그런데, 문득 들은 생각인데,
처음부터 3 * 3 으로 자를 수 있는 경우를 구하기 전에
입력받은 보드를 아예 좌측 상단이 B인 것과, 좌측 상단이 W인 것으로 나누어 테이블을 만들고,

좌측 상단이 B 인것
BWBW
WBWB
BWBW
WBWB

좌측 상단이 W 인것
WBWB
BWBW
WBWB
BWBW

이렇게 있으면,
누적합 테이블을 b누적합테이블, w누적합 테이블 이렇게 두개 만들어서
정상적인 체스판과 다른 부분의 개수를 카운트해서 갱신하고,
거기서 3 * 3 크기에 해당하는 부분의 누적합을 구해서 가장 작은 부분을 반환하면 되지 않을까?

코드로 구현해보자.

일단 시간초과 난다.


ii)
처음 생각한 기본 로직은 맞는 것 같음.
그러면 이제 시간복잡도, 공간복잡도 등을 줄일 수 있는 방법을 생각해보자.

일단, 생각을 해보니까,
체스판의 좌측 상단이 B인 경우와 W인 경우를 나눠서 둘다 구할 필요가 없는 것 같다.
왜냐하면, 체스판의 전체 수 - 좌측 상단이 B로 시작한 체스판에서 수정해야 하는 개수 = w로 직한판 바둑판에서 B로 수정해야 하는 개수 가 성립한다.
그리고, 정상배열도 안만들어 놓아도 될 것 같다. 왜냐하면, 규칙으로 대체 가능하기 때문이다.

결국 로직은,

맨 위, 왼쪽에 흰색일 경우와 검은색일 경우를 배열은 선언하고 비교해서 다른면 1 같은면 0으로 표시를 한다. (인덱스 1부터 시작한다하면, 행과 열 더해서 짝수이면 같고 홀수이면 다르다.)
탐색이 끝나면 그 배열의 누적합을 구한다.
누적합을 구한 2차원 배열에서 K × K  구간합중 가장 작은 값을 구하고 맨위 왼쪽 흰색인 경우와 검은색인 경우중 작은 작은 값을 출력하면된다.


---
2차원 dp 배열을 만들어서 시작점이 W 일때와 B 일때 누적합을 구해준다.

이후 K×K 크기만큼 배열을 탐색해서 누적합의 최소값을 찾는다.

dp 배열의 2차원 누적합은
dp[i+1][j+1]=dp[i][j+1]+dp[i+1][j]−dp[i][j]+value
으로 계산해준다. 이때 value 는 체스판이 color 와 같으면 1 아니면 0 을 가지게 된다.

value=L[i][j]!=color -> if L[i][j]!=color : value=1 과 같다

K×K 체스판에서의 누적합을 구하는 점화식은
dp[i+K−1][j+K−1]−dp[i+K−1][j−1]−dp[i−1][j+K−1]+dp[i−1][j−1]
와 같다. 기존의 누적합 식에 K를 넣어주었다.

출력은 print(min(Chess('W'),Chess('B'))) 를 통해 최소값을 구할수 있다.

총 2번의 탐색을 하기때문에 시간초과가 발생할수 있으므로 pypy3 로 제출해야한다.
'''

import sys
sys.maxsize

# n, m, k 입력받기
n, m, k = map(int, sys.stdin.readline().rstrip().split())
# 보드 입력받아서 저장하기
board = []
for i in range(n):
    str = list(sys.stdin.readline().rstrip())
    board.append(str)
# print(board)

def chess(color):
    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(n):
        for j in range(m):
            if (i + j) % 2 == 0:    # 인덱스가 0부터 시작하는 것을 고려했을 때, board의 행과 열을 더해서 짝수이면 color와 다르고 (1)
                value = board[i][j] != color
            else:   # 인덱스가 0부터 시작하는 것을 고려했을 때, board의 행과 열을 더해서 홀수이면 color와 같다 (0)
                value = board[i][j] == color
            prefix_sum[i + 1][j + 1] = prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] + value   # 2차원 배열의 누적합을 구하는 것이다. -prefix_sum[i][j]는 중복으로 더한 부분을 한번 뺴준 것.


    count = sys.maxsize
    for i in range(1, n - k + 2):
        for j in range(1, m - k + 2):
            count = min(count, prefix_sum[i + k - 1][j + k - 1] - prefix_sum[i + k - 1][j - 1] - prefix_sum[i - 1][j + k - 1] + prefix_sum[i - 1][j - 1])   # 2차원 배열의 누적합 점화식에 k 고려해서 작성한 것임다.
    return count

print(min(chess('B'), chess('W')))
